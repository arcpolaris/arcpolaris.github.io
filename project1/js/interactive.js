var canvas = document.getElementById("canvas");

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    mult(scalar) {
        this.x *= scalar;
        this.y *= scalar;
    }
    mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    static diff(a, b) {
        let x = a.x - b.x;
        let y = a.y - b.y;
        return new Point(x, y);
    }
    static dist(a, b) {
        return Point.diff(a, b).mag();
    }
}

function getSize() {
    let rect = canvas.getBoundingClientRect();
    let p = new Point(rect.width, rect.height);

    return p;
}
function resize() {
    canvas.width = canvas.getBoundingClientRect().width;
    canvas.height = canvas.getBoundingClientRect().height;
}
resize();

var ctx = canvas.getContext("2d");

//This function was generated by ChatGPT.
//Based on how complicated it is to convert from RGB to HSV,
//I think that this is fine.
//Also I understand how most this works from a math perspective,
//Just writing all of this would be hell
function vectorToRGB(v, value) {
    const angle = Math.atan2(v.y, v.x) * (180 / Math.PI);
    const normalizedAngle = (angle + 360) % 360;
    const hue = normalizedAngle / 360; // Convert to [0, 1]
    const saturation = Math.min(v.mag() / 20, 1); // Assuming max length for full saturation is 100
    //const value = Math.min(v.mag() / 20, 1); // Assuming max length for full value is 100


    const i = Math.floor(hue * 6);
    const f = hue * 6 - i;
    const p = 255 * value * (1 - saturation);
    const q = 255 * value * (1 - f * saturation);
    const t = 255 * value * (1 - (1 - f) * saturation);
    let r, g, b;
    switch (i % 6) {
        case 0: r = 255 * value, g = t, b = p; break;
        case 1: r = q, g = 255 * value, b = p; break;
        case 2: r = p, g = 255 * value, b = t; break;
        case 3: r = p, g = q, b = 255 * value; break;
        case 4: r = t, g = p, b = 255 * value; break;
        case 5: r = 255 * value, g = p, b = q; break;
    }
    return [Math.round(r), Math.round(g), Math.round(b)];
}


var pre;

function update(e) {
    let mouse = new Point(e.clientX, e.clientY);
    if (!pre) {
        pre = mouse;
        return;
    }
    let delta = Point.diff(mouse, pre);
    console.log(delta.mag());

    let size = getSize();
    let img = ctx.getImageData(0, 0, size.x, size.y);
    for (let x = 0; x < size.x; x++) {
        for (let y = 0; y < size.y; y++) {
            let point = new Point(x, y);
            let i = 4 * (x + y * size.x);

            let d = Point.dist(point, mouse);
            let color = vectorToRGB(delta);
            let a = 1;
            if (d < 10) {
                img.data[i + 0] = color[0];
                img.data[i + 1] = color[1];
                img.data[i + 2] = color[2];
                img.data[i + 3] = 255 * a;
            }
            else {
                img.data[i + 0] = Math.max(0, img.data[i + 0] - 1);
                img.data[i + 1] = Math.max(0, img.data[i + 1] - 1);
                img.data[i + 2] = Math.max(0, img.data[i + 2] - 1);
                img.data[i + 3] = 255 * a;
            }
        }
    }
    ctx.putImageData(img, 0, 0);
    pre = mouse;
}
canvas.addEventListener("mousemove", update);
window.addEventListener("resize", resize);